use http::Method;
use std::sync::Arc;
use std::time::Duration;
use streamweave::{
  consumers::vec::vec_consumer::VecConsumer,
  http::{
    http_handler::HttpHandler, http_request_chunk::StreamWeaveHttpRequestChunk,
    http_response::StreamWeaveHttpResponse, route_pattern::RoutePattern,
  },
  pipeline::PipelineBuilder,
  producers::vec::vec_producer::VecProducer,
  transformer::{Transformer, TransformerConfig},
  transformers::{
    backpressure::backpressure_transformer::BackpressureTransformer,
    http_response_builder::{
      builder_utils::{ErrorResponseBuilder, HtmlResponseBuilder, JsonResponseBuilder},
      response_data::ResponseData,
    },
    http_router::transformer::HttpRouterTransformer,
    map::map_transformer::MapTransformer,
  },
};

/// Handler for echo endpoint with streaming capabilities
struct EchoHandler;

#[async_trait::async_trait]
impl HttpHandler for EchoHandler {
  async fn handle(&self, request: StreamWeaveHttpRequestChunk) -> StreamWeaveHttpResponse {
    let path = request.path();
    let method = &request.method;

    // Extract message from path parameter
    let message = path.strip_prefix("/echo/").unwrap_or("world");

    // Simulate some processing time for streaming effect
    tokio::time::sleep(Duration::from_millis(200)).await;

    // Use HTTP Response Builder for structured HTML response
    let response_data = HtmlResponseBuilder::with_status(http::StatusCode::OK)
      .content(&format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamWeave Echo</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
        }}
        .container {{
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }}
        h1 {{
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }}
        .echo-message {{
            font-size: 3em;
            font-weight: bold;
            margin: 30px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }}
        .info {{
            font-size: 1.1em;
            opacity: 0.9;
            margin-top: 30px;
        }}
        .timestamp {{
            font-size: 0.9em;
            opacity: 0.7;
            margin-top: 20px;
        }}
        .streaming-badge {{
            background: rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 0.9em;
            margin-top: 20px;
            display: inline-block;
        }}
        .pipeline-info {{
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            text-align: left;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”„ StreamWeave Echo</h1>
        <div class="echo-message">{}</div>
        <div class="info">
            <p>This response was generated by StreamWeave's <strong>streaming</strong> HTTP pipeline</p>
            <p>Route parameter: <code>/echo/{}</code></p>
            <p>Processed through the streaming pipeline with backpressure control</p>
        </div>
        <div class="pipeline-info">
            <h3>ğŸš€ Pipeline Architecture</h3>
            <ul>
                <li><strong>HTTP Router:</strong> Request routing with path parameters</li>
                <li><strong>HTTP Response Builder:</strong> Structured response generation</li>
                <li><strong>Backpressure Control:</strong> Prevents memory overflow</li>
                <li><strong>Streaming Processing:</strong> Real-time data flow</li>
                <li><strong>Method:</strong> {}</li>
                <li><strong>Path:</strong> {}</li>
            </ul>
        </div>
        <div class="streaming-badge">ğŸš€ STREAMING PIPELINE</div>
        <div class="timestamp">
            Generated at: {}
        </div>
    </div>
</body>
</html>"#,
        message.to_uppercase(),
        message,
        method.as_str(),
        path,
        chrono::Utc::now()
          .format("%Y-%m-%d %H:%M:%S UTC")
          .to_string()
      ))
      .header("x-powered-by", "StreamWeave HTTP Response Builder")
      .header("x-streaming", "true")
      .build();

    // Convert ResponseData to StreamWeaveHttpResponse
    match response_data {
      ResponseData::Success {
        status,
        headers,
        body,
      } => StreamWeaveHttpResponse::new(status, headers, body),
      ResponseData::Error { status, message } => {
        StreamWeaveHttpResponse::new(status, http::HeaderMap::new(), message.into())
      }
    }
  }
}

/// Handler for streaming data endpoint
struct StreamingDataHandler;

#[async_trait::async_trait]
impl HttpHandler for StreamingDataHandler {
  async fn handle(&self, request: StreamWeaveHttpRequestChunk) -> StreamWeaveHttpResponse {
    let path = request.path();
    let method = &request.method;

    // Simulate streaming data processing
    tokio::time::sleep(Duration::from_millis(300)).await;

    // Use JSON Response Builder for structured streaming data
    let response_data = JsonResponseBuilder::with_status(http::StatusCode::OK)
      .string_field("endpoint", "streaming-data")
      .string_field("method", method.as_str())
      .string_field("path", path)
      .string_field("type", "streaming")
      .array_field(
        "data_chunks",
        vec![
          serde_json::json!({"chunk": 1, "data": "First streaming chunk", "timestamp": chrono::Utc::now().to_rfc3339()}),
          serde_json::json!({"chunk": 2, "data": "Second streaming chunk", "timestamp": chrono::Utc::now().to_rfc3339()}),
          serde_json::json!({"chunk": 3, "data": "Third streaming chunk", "timestamp": chrono::Utc::now().to_rfc3339()}),
        ],
      )
      .string_field("status", "streaming_complete")
      .string_field("pipeline", "StreamWeave HTTP Router + Response Builder")
      .header("x-streaming", "true")
      .header("x-chunks", "3")
      .build();

    // Convert ResponseData to StreamWeaveHttpResponse
    match response_data {
      ResponseData::Success {
        status,
        headers,
        body,
      } => StreamWeaveHttpResponse::new(status, headers, body),
      ResponseData::Error { status, message } => {
        StreamWeaveHttpResponse::new(status, http::HeaderMap::new(), message.into())
      }
    }
  }
}

/// Handler for real-time metrics endpoint
struct MetricsHandler;

#[async_trait::async_trait]
impl HttpHandler for MetricsHandler {
  async fn handle(&self, _request: StreamWeaveHttpRequestChunk) -> StreamWeaveHttpResponse {
    // Simulate real-time metrics collection
    tokio::time::sleep(Duration::from_millis(150)).await;

    let response_data = JsonResponseBuilder::with_status(http::StatusCode::OK)
      .string_field("endpoint", "real-time-metrics")
      .string_field("type", "streaming_metrics")
      .number_field("requests_per_second", 45.6)
      .number_field("active_connections", 12.0)
      .number_field("memory_usage_mb", 128.5)
      .number_field("cpu_usage_percent", 23.4)
      .string_field("timestamp", &chrono::Utc::now().to_rfc3339())
      .string_field("pipeline_status", "streaming")
      .header("x-metrics", "real-time")
      .header("x-update-interval", "1s")
      .build();

    // Convert ResponseData to StreamWeaveHttpResponse
    match response_data {
      ResponseData::Success {
        status,
        headers,
        body,
      } => StreamWeaveHttpResponse::new(status, headers, body),
      ResponseData::Error { status, message } => {
        StreamWeaveHttpResponse::new(status, http::HeaderMap::new(), message.into())
      }
    }
  }
}

/// Fallback handler for 404 responses
struct NotFoundHandler;

#[async_trait::async_trait]
impl HttpHandler for NotFoundHandler {
  async fn handle(&self, request: StreamWeaveHttpRequestChunk) -> StreamWeaveHttpResponse {
    let response_data = ErrorResponseBuilder::not_found(&format!(
      "No streaming endpoint found for {} {}",
      request.method,
      request.path()
    ))
    .header("x-powered-by", "StreamWeave HTTP Response Builder")
    .header("x-streaming", "false")
    .build();

    // Convert ResponseData to StreamWeaveHttpResponse
    match response_data {
      ResponseData::Success {
        status,
        headers,
        body,
      } => StreamWeaveHttpResponse::new(status, headers, body),
      ResponseData::Error { status, message } => {
        StreamWeaveHttpResponse::new(status, http::HeaderMap::new(), message.into())
      }
    }
  }
}

/// Create test requests for streaming HTTP endpoints
fn create_test_requests() -> Vec<StreamWeaveHttpRequestChunk> {
  let mut requests = Vec::new();

  // Helper function to create a request
  let create_request = |method: Method, path: &str, headers: http::HeaderMap, body: &str| {
    let uri: http::Uri = format!("http://localhost:3000{}", path).parse().unwrap();
    let connection_info = streamweave::http::connection_info::ConnectionInfo::new(
      std::net::SocketAddr::new(std::net::IpAddr::V4(std::net::Ipv4Addr::new(127, 0, 0, 1)), 8080),
      std::net::SocketAddr::new(std::net::IpAddr::V4(std::net::Ipv4Addr::new(0, 0, 0, 0)), 3000),
      http::Version::HTTP_11,
    );

    StreamWeaveHttpRequestChunk::new(
      method,
      uri,
      headers,
      bytes::Bytes::from(body.to_string()),
      connection_info,
      true,
    )
  };

  // 1. Echo endpoint with message
  let mut headers = http::HeaderMap::new();
  headers.insert("user-agent", "StreamWeave Test Client".parse().unwrap());
  headers.insert("accept", "text/html,application/json".parse().unwrap());
  requests.push(create_request(Method::GET, "/echo/hello", headers, ""));

  // 2. Echo endpoint with different message
  let mut headers = http::HeaderMap::new();
  headers.insert("user-agent", "StreamWeave Test Client".parse().unwrap());
  headers.insert("accept", "text/html".parse().unwrap());
  requests.push(create_request(Method::GET, "/echo/streaming", headers, ""));

  // 3. Streaming data endpoint
  let mut headers = http::HeaderMap::new();
  headers.insert("user-agent", "StreamWeave Test Client".parse().unwrap());
  headers.insert("accept", "application/json".parse().unwrap());
  requests.push(create_request(Method::GET, "/streaming/data", headers, ""));

  // 4. Real-time metrics endpoint
  let mut headers = http::HeaderMap::new();
  headers.insert("user-agent", "StreamWeave Test Client".parse().unwrap());
  headers.insert("accept", "application/json".parse().unwrap());
  requests.push(create_request(Method::GET, "/metrics", headers, ""));

  // 5. Non-existent endpoint (404)
  let mut headers = http::HeaderMap::new();
  headers.insert("user-agent", "StreamWeave Test Client".parse().unwrap());
  requests.push(create_request(Method::GET, "/nonexistent", headers, ""));

  requests
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
  // Initialize logging
  tracing_subscriber::fmt::init();

  println!("ğŸš€ StreamWeave HTTP Streaming Example");
  println!("=====================================");
  println!("Now featuring HTTP Router and HTTP Response Builder integration!");
  println!("Demonstrates streaming capabilities with full StreamWeave architecture");
  println!();

  // Create route patterns
  let echo_route = RoutePattern::new(Method::GET, "/echo/{message}")?;
  let streaming_data_route = RoutePattern::new(Method::GET, "/streaming/data")?;
  let metrics_route = RoutePattern::new(Method::GET, "/metrics")?;

  // Create handlers
  let echo_handler = Arc::new(EchoHandler);
  let streaming_data_handler = Arc::new(StreamingDataHandler);
  let metrics_handler = Arc::new(MetricsHandler);
  let not_found_handler = Arc::new(NotFoundHandler);

  // Build the HTTP router transformer
  let mut router = HttpRouterTransformer::new()
    .add_route(echo_route, "echo".to_string(), echo_handler)?
    .add_route(streaming_data_route, "streaming_data".to_string(), streaming_data_handler)?
    .add_route(metrics_route, "metrics".to_string(), metrics_handler)?
    .with_fallback_handler(not_found_handler);

  router.set_config(TransformerConfig::default().with_name("http_router".to_string()));

  // Create test requests
  let test_requests = create_test_requests();

  println!(
    "ğŸ“ Processing {} test requests through complete StreamWeave streaming pipeline",
    test_requests.len()
  );
  println!("========================================================================");

  // Process all requests through the complete streaming pipeline
  let request_producer =
    VecProducer::new(test_requests).with_name("streaming_request_producer".to_string());

  let response_consumer =
    VecConsumer::<StreamWeaveHttpResponse>::new().with_name("streaming_response_collector".to_string());

  let pipeline = PipelineBuilder::new()
    .producer(request_producer)
    .transformer(BackpressureTransformer::new(10)) // Add backpressure control for streaming
    .transformer(MapTransformer::new(|chunk: StreamWeaveHttpRequestChunk| {
      // Simulate streaming processing with some delay
      println!(
        "  ğŸ“¥ Processing streaming chunk: {} {} ({} bytes)",
        chunk.method.as_str(),
        chunk.uri.path(),
        chunk.chunk.len()
      );
      chunk
    }))
    .transformer(router)
    ._consumer(response_consumer);

  let pipeline_result = pipeline.run().await;

  match pipeline_result {
    Ok(((), consumer)) => {
      let responses = consumer.into_vec();
      println!("\nğŸ‰ StreamWeave Streaming Pipeline Processing Complete!");
      println!("=====================================================");

      for (i, response) in responses.into_iter().enumerate() {
        println!("\n--- Streaming Response {} ---", i + 1);
        println!("Status: {}", response.status);
        println!("Headers: {}", response.headers.len());
        println!("Body size: {} bytes", response.body.len());

        // Show some key headers
        if let Some(content_type) = response.headers.get("content-type") {
          println!(
            "Content-Type: {}",
            content_type.to_str().unwrap_or("invalid")
          );
        }
        if let Some(streaming) = response.headers.get("x-streaming") {
          println!("Streaming: {}", streaming.to_str().unwrap_or("invalid"));
        }
        if let Some(powered_by) = response.headers.get("x-powered-by") {
          println!("Powered By: {}", powered_by.to_str().unwrap_or("invalid"));
        }

        // Show a preview of the response body
        let body_preview = String::from_utf8_lossy(&response.body);
        let preview = if body_preview.len() > 200 {
          format!("{}...", &body_preview[..200])
        } else {
          body_preview.to_string()
        };
        println!("Body preview: {}", preview);
      }
    }
    Err(e) => {
      println!("âŒ Pipeline error: {}", e);
    }
  }

  println!("\nğŸ‰ HTTP Streaming example completed successfully!");
  println!("\nKey Features Demonstrated:");
  println!("â€¢ ğŸ›£ï¸  HTTP Router: Request routing with path parameters and fallback handling");
  println!("â€¢ ğŸ†• HTTP Response Builder: Structured response generation with security headers");
  println!("â€¢ ğŸ”— StreamWeave Architecture: Complete request-to-response pipeline in one stream");
  println!("â€¢ ğŸ”„ Streaming Processing: Real-time data flow with backpressure control");
  println!("â€¢ ğŸ“Š Multiple Endpoints:");
  println!("  - /echo/{{message}} - Echo endpoint with beautiful HTML responses");
  println!("  - /streaming/data - Streaming data endpoint with JSON responses");
  println!("  - /metrics - Real-time metrics endpoint");
  println!("  - 404 handling for non-existent endpoints");
  println!("â€¢ ğŸš€ Pipeline Features:");
  println!("  - Backpressure control to prevent memory overflow");
  println!("  - Streaming data processing with real-time flow");
  println!("  - HTTP Response Builder integration for structured responses");
  println!("  - Path parameter extraction and processing");
  println!("  - Error handling and fallback responses");

  Ok(())
}
