use axum::{
  Router,
  body::Body,
  extract::{Path, Request},
  http::StatusCode,
  response::{Html, Response},
  routing::get,
};
use std::net::SocketAddr;
use tokio;
use tower_http::cors::CorsLayer;

use streamweave::{
  consumers::http_response::{ResponseChunk, StreamingHttpResponseConsumer},
  pipeline::PipelineBuilder,
  producers::http_request::{StreamWeaveHttpRequestChunk, StreamingHttpRequestProducer},
  transformers::{backpressure::BackpressureTransformer, map::MapTransformer},
};

// StreamWeave pipeline processor for streaming HTTP requests
async fn process_request_through_streamweave_streaming(
  req: Request,
) -> Result<Response<Body>, (StatusCode, String)> {
  println!("üöÄ Processing request through StreamWeave pipeline (streaming mode)");

  // Extract the path from the request to determine the response type
  let path = req.uri().path().to_string();
  let is_echo_request = path.starts_with("/streaming/echo/");

  // Create streaming StreamWeave pipeline
  let (consumer, mut chunk_receiver) = StreamingHttpResponseConsumer::new();

  // Spawn pipeline processing
  let pipeline_handle = tokio::spawn(async move {
    let _pipeline = PipelineBuilder::new()
      .producer(StreamingHttpRequestProducer::from_axum_request(req).await)
      .transformer(BackpressureTransformer::new(10)) // Add backpressure control
      .transformer(MapTransformer::new(|chunk: StreamWeaveHttpRequestChunk| {
        // Process each chunk of the request
        let path = chunk.uri.path();
        let method = chunk.method.as_str();

        println!(
          "  üì• Processing chunk: {} {} ({} bytes)",
          method,
          path,
          chunk.chunk.len()
        );

        // For this example, we'll echo the chunk back as a ResponseChunk
        ResponseChunk::body(chunk.chunk)
      }))
      ._consumer(consumer)
      .run()
      .await?;
    Ok::<(), Box<dyn std::error::Error + Send + Sync>>(())
  });

  // Wait for pipeline to complete
  let _ = pipeline_handle.await;

  // Build streaming response
  let mut response_builder = Response::builder();
  let mut body_chunks = Vec::new();

  // Process response chunks
  while let Some(chunk) = chunk_receiver.recv().await {
    match chunk {
      ResponseChunk::Header(status, headers) => {
        response_builder = response_builder.status(status);
        for (key, value) in headers {
          if let Some(key) = key {
            response_builder = response_builder.header(key, value);
          }
        }
      }
      ResponseChunk::Body(data) => {
        body_chunks.push(data);
      }
      ResponseChunk::End => break,
      ResponseChunk::Error(status, message) => {
        return Err((status, message));
      }
    }
  }

  // Handle echo requests specially
  if is_echo_request {
    // Extract the message from the path
    let message = path.trim_start_matches("/streaming/echo/");
    let html_content = format!(
      r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamWeave Streaming Echo</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
            text-align: center;
        }}
        .container {{
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }}
        h1 {{
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }}
        .echo-message {{
            font-size: 3em;
            font-weight: bold;
            margin: 30px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }}
        .info {{
            font-size: 1.1em;
            opacity: 0.9;
            margin-top: 30px;
        }}
        .timestamp {{
            font-size: 0.9em;
            opacity: 0.7;
            margin-top: 20px;
        }}
        .streaming-badge {{
            background: rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 0.9em;
            margin-top: 20px;
            display: inline-block;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üîÑ StreamWeave Streaming Echo</h1>
        <div class="echo-message">{}</div>
        <div class="info">
            <p>This response was generated by StreamWeave's <strong>streaming</strong> HTTP pipeline</p>
            <p>Route parameter: <code>/streaming/echo/{}</code></p>
            <p>Processed through the streaming pipeline with backpressure control</p>
        </div>
        <div class="streaming-badge">üöÄ STREAMING PIPELINE</div>
        <div class="timestamp">
            Generated at: {}
        </div>
    </div>
</body>
</html>"#,
      message.to_uppercase(),
      message,
      chrono::Utc::now()
        .format("%Y-%m-%d %H:%M:%S UTC")
        .to_string()
    );

    return Ok(
      Response::builder()
        .status(StatusCode::OK)
        .header("content-type", "text/html; charset=utf-8")
        .body(Body::from(html_content))
        .unwrap(),
    );
  }

  // Convert chunks to streaming body - use a simple approach for now
  let body = if body_chunks.is_empty() {
    Body::from("No data")
  } else {
    // For simplicity, concatenate all chunks
    let combined = body_chunks.into_iter().fold(Vec::new(), |mut acc, chunk| {
      acc.extend_from_slice(&chunk);
      acc
    });
    Body::from(combined)
  };

  // Set default status if none was set
  let response_builder = response_builder.status(StatusCode::OK);

  // Set default content type based on the path
  let content_type = if path.contains("json") {
    "application/json"
  } else if path.contains("xml") {
    "application/xml"
  } else if path.contains("text") || path.contains("echo") {
    "text/plain; charset=utf-8"
  } else {
    "text/plain; charset=utf-8"
  };

  let response_builder = response_builder.header("content-type", content_type);

  Ok(response_builder.body(body).unwrap())
}

// Echo endpoint with route parameter - returns HTML page
async fn echo_route(Path(message): Path<String>) -> Html<String> {
  let html_content = format!(
    r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamWeave Echo</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-align: center;
        }}
        .container {{
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }}
        h1 {{
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }}
        .echo-message {{
            font-size: 3em;
            font-weight: bold;
            margin: 30px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }}
        .info {{
            font-size: 1.1em;
            opacity: 0.9;
            margin-top: 30px;
        }}
        .timestamp {{
            font-size: 0.9em;
            opacity: 0.7;
            margin-top: 20px;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ StreamWeave Echo</h1>
        <div class="echo-message">{}</div>
        <div class="info">
            <p>This response was generated by StreamWeave's streaming HTTP pipeline</p>
            <p>Route parameter: <code>/echo/{}</code></p>
        </div>
        <div class="timestamp">
            Generated at: {}
        </div>
    </div>
</body>
</html>"#,
    message.to_uppercase(),
    message,
    chrono::Utc::now()
      .format("%Y-%m-%d %H:%M:%S UTC")
      .to_string()
  );

  Html(html_content)
}

// Health check endpoint
async fn health_check() -> Html<String> {
  let html_content = r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamWeave Health Check</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            text-align: center;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .status {
            font-size: 2em;
            font-weight: bold;
            margin: 30px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .info {
            font-size: 1.1em;
            opacity: 0.9;
            margin-top: 30px;
        }
        .timestamp {
            font-size: 0.9em;
            opacity: 0.7;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè• StreamWeave Health Check</h1>
        <div class="status">‚úÖ HEALTHY</div>
        <div class="info">
            <p>StreamWeave HTTP streaming server is running successfully</p>
            <p>All systems operational</p>
        </div>
        <div class="timestamp">
            Checked at: "#
    .to_string()
    + &chrono::Utc::now()
      .format("%Y-%m-%d %H:%M:%S UTC")
      .to_string()
    + r#"
        </div>
    </div>
</body>
</html>"#;

  Html(html_content)
}

// API status endpoint
async fn api_status() -> Html<String> {
  let html_content = r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamWeave API Status</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            text-align: center;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .status {
            font-size: 2em;
            font-weight: bold;
            margin: 30px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        .info {
            font-size: 1.1em;
            opacity: 0.9;
            margin-top: 30px;
        }
        .timestamp {
            font-size: 0.9em;
            opacity: 0.7;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üì° StreamWeave API Status</h1>
        <div class="status">üöÄ OPERATIONAL</div>
        <div class="info">
            <p>StreamWeave HTTP streaming API is fully operational</p>
            <p>Ready to process streaming requests</p>
        </div>
        <div class="timestamp">
            Status checked at: "#
    .to_string()
    + &chrono::Utc::now()
      .format("%Y-%m-%d %H:%M:%S UTC")
      .to_string()
    + r#"
        </div>
    </div>
</body>
</html>"#;

  Html(html_content)
}

#[tokio::main]
async fn main() {
  println!("üöÄ StreamWeave HTTP Streaming Server");
  println!("üì° Built with Axum + StreamWeave");
  println!("üîÑ Streaming-only architecture - no buffering!");
  println!();

  // Build our application with routes
  let app = Router::new()
    .route("/health", get(health_check))
    .route("/echo/{message}", get(echo_route))
    .route("/api/status", get(api_status))
    .route(
      "/streaming/{*path}",
      get(process_request_through_streamweave_streaming),
    )
    .layer(CorsLayer::permissive());

  // Run it
  let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
  println!("üåê Server starting on {}", addr);
  println!("üìã Available endpoints:");
  println!("   GET  /health                    - Health check page");
  println!("   GET  /echo/:message             - Echo endpoint with route parameter");
  println!("   GET  /api/status                - API status page");
  println!("   GET  /streaming/*               - Streaming endpoint via StreamWeave pipeline");
  println!();
  println!("üîó Test endpoints:");
  println!("   Browser: http://localhost:3000/health");
  println!("   Browser: http://localhost:3000/echo/hello");
  println!("   Browser: http://localhost:3000/api/status");
  println!("   Browser: http://localhost:3000/streaming/test");
  println!();
  println!("üéâ All endpoints now use GET requests for easy browser testing!");
  println!("   - Echo endpoint takes route parameters like /echo/abcd");
  println!("   - Returns beautiful HTML pages with the echoed message");
  println!("   - Streaming pipeline available at /streaming/*");

  let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
  println!("‚úÖ Server listening on {}", addr);

  axum::serve(listener, app).await.unwrap();
}
