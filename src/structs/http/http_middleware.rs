use crate::structs::http::{
  http_request_chunk::StreamWeaveHttpRequestChunk, http_response::StreamWeaveHttpResponse,
};

/// Trait for HTTP middleware
#[async_trait::async_trait]
pub trait HttpMiddleware: Send + Sync {
  /// Process a request before it reaches the handler
  async fn process_request(
    &self,
    request: &mut StreamWeaveHttpRequestChunk,
  ) -> Result<(), HttpMiddlewareError>;

  /// Process a response after it's generated by the handler
  async fn process_response(
    &self,
    response: &mut StreamWeaveHttpResponse,
  ) -> Result<(), HttpMiddlewareError>;
}

/// Error types for HTTP middleware
#[derive(Debug, Clone, PartialEq)]
pub enum HttpMiddlewareError {
  AuthenticationFailed,
  AuthorizationFailed,
  RateLimitExceeded,
  ValidationFailed(String),
  InternalError(String),
}

impl std::fmt::Display for HttpMiddlewareError {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    match self {
      HttpMiddlewareError::AuthenticationFailed => write!(f, "Authentication failed"),
      HttpMiddlewareError::AuthorizationFailed => write!(f, "Authorization failed"),
      HttpMiddlewareError::RateLimitExceeded => write!(f, "Rate limit exceeded"),
      HttpMiddlewareError::ValidationFailed(msg) => write!(f, "Validation failed: {}", msg),
      HttpMiddlewareError::InternalError(msg) => write!(f, "Internal error: {}", msg),
    }
  }
}

impl std::error::Error for HttpMiddlewareError {}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_http_middleware_error_display() {
    let auth_error = HttpMiddlewareError::AuthenticationFailed;
    assert_eq!(auth_error.to_string(), "Authentication failed");

    let validation_error = HttpMiddlewareError::ValidationFailed("Invalid input".to_string());
    assert_eq!(
      validation_error.to_string(),
      "Validation failed: Invalid input"
    );
  }
}
